@on compile
@require trident-util:type_checking

local var rangeToObj = function(value) {
    if(value is int) {
        if(value.min == value.max && value.min != null) return value.min
        var range = value
        eval value = {}
        if(range.min != null) eval value.min = range.min
        if(range.max != null) eval value.max = range.max
        return value
    }
    if(value is real_range) {
        if(value.min == value.max && value.min != null) return value.min
        var range = value
        eval value = {}
        if(range.min != null) eval value.min = range.min
        if(range.max != null) eval value.max = range.max
        return value
    }
    if(value is real) {
        return value
    }
}

define local class JSONSerializable {
    public var serialized

    public serializeToJSON() {
        throw "serializeToJSON not implemented by " + type_definition.of(this)
    }

    public static fullySerialize(obj) {
        if(obj is JSONSerializable) {
            eval obj = obj.serializeToJSON()
        }

        if(obj is dictionary) {
            for(entry in obj) {
                eval obj[entry.key] = fullySerialize(entry.value)
            }
        } else if(obj is list) {
            for(var i = 0; i < obj.length; i++) {
                eval obj[i] = fullySerialize(obj[i])
            }
        }

        return obj
    }
}

define private class Distance
define private class Location
define private class Entity
define private class Effect
define private class Item
define private class Enchantment
define private class Block
define private class Fluid

define private class Entity : JSONSerializable {
    var output = {}

    public type(type : resource) {
        if(type.isTag && !Tags.exists("entity", type)) throw "Given tag '" + type + "' does not exist as an entity tag"
        if(!type.isTag && !MinecraftTypes.exists("entity", type)) throw "Given type '" + type + "' does not exist as an entity type"
        eval this.output.type = type
        return this
    }
    public distance(distance : Distance) {
        eval output.distance = distance
        return this
    }
    public location(location : Location) {
        eval output.location = location
        return this
    }
    public effect(obj : Effect) {
        return effects([obj])
    }
    public effects(obj : list) {
        if(this.output.effects == null) eval this.output.effects = {}
        for(element in obj) {
            var effect : Effect = element
            var effectSerialized = ((JSONSerialization) effect).serialized
            eval this.output.effects[(string)effectSerialized.id] = effectSerialized
            eval effectSerialized.id = null
        }
        return this
    }
    public nbt(tag : nbt) {
        if(this.output.nbt == null) eval this.output.nbt = nbt<{}>
        eval this.output.nbt = this.output.nbt.merge(tag)
        return this
    }
    public isOnFire(bool : boolean) {
        if(this.output.flags == null) eval this.output.flags = {}
        eval this.output.flags.is_on_fire = bool
        return this
    }
    public isSneaking(bool : boolean) {
        if(this.output.flags == null) eval this.output.flags = {}
        eval this.output.flags.is_sneaking = bool
        return this
    }
    public isSprinting(bool : boolean) {
        if(this.output.flags == null) eval this.output.flags = {}
        eval this.output.flags.is_sprinting = bool
        return this
    }
    public isSwimming(bool : boolean) {
        if(this.output.flags == null) eval this.output.flags = {}
        eval this.output.flags.is_swimming = bool
        return this
    }
    public isBaby(bool : boolean) {
        if(this.output.flags == null) eval this.output.flags = {}
        eval this.output.flags.is_baby = bool
        return this
    }
    public equipment(slot : string, itm : item) {
        return equipment(slot, new Shared.Item(itm))
    }
    public equipment(slot : string, itm : custom_item) {
        return equipment(slot, new Shared.Item(itm))
    }
    public equipment(slot : string, itm : Item) {
        if(this.output.equipment == null) eval this.output.equipment = {}
        eval assertOneOf(slot, ["mainhand", "offhand", "head", "chest", "legs", "feet"])
        eval this.output.equipment[slot] = itm
        return this
    }
    public team(teamName : string) {
        eval this.output.team = teamName
        return this
    }
    public level(value : int) {
        if(this.output.player == null) eval this.output.player = {}
        eval this.output.player.level = value
        return this
    }
    public level(value : int_range) {
        if(this.output.player == null) eval this.output.player = {}
        eval this.output.player.level = rangeToObj(value)
        return this
    }
    public gamemode(gamemode : string) {
        if(this.output.player == null) eval this.output.player = {}
        if(!MinecraftTypes.exists("gamemode", gamemode)) throw "Given type '" + gamemode + "' does not exist as a gamemode type"
        eval this.output.player.gamemode = gamemode
        return this
    }
    public matchStats(base : string, criterion : string, value : int_range) {
        eval assertOneOf(base, ["minecraft:custom", "minecraft:crafted", "minecraft:used", "minecraft:broken", "minecraft:mined", "minecraft:killed", "minecraft:picked_up", "minecraft:dropped", "minecraft:killed_by", "killedByTeam", "teamkill"])
        if(this.output.player == null) eval this.output.player = {}
        if(this.output.player.stats == null) eval this.output.player.stats = []
        eval this.output.player.stats.add({type: base, stat: criterion, value: rangeToObj(value)})
        return this
    }
    public matchRecipes(id : resource, value : boolean) {
        return matchRecipes((string) resource, value)
    }
    public matchRecipes(id : string, value : boolean) {
        if(this.output.player == null) eval this.output.player = {}
        if(this.output.player.recipes == null) eval this.output.player.recipes = {}
        eval this.output.player.recipes[id] = value
        return this
    }
    public catType(texture : resource) {
        eval this.output.catType = texture
        return this
    }

    public override serializeToJSON() {
        if(Project.getTargetVersion()[1] < 16 && output.player != null) {
            # From 1.16 onwards, player-related conditions belong inside a "player" sub object
            # This reverses that for pre-1.16 projects
            for(entry in output.player) {
                eval output[entry.key] = entry.value
            }
            eval output.player = null
        }
        return output
    }
}

define private class Distance : JSONSerializable {
    var output = {}

    public x(value : real_range) {
        eval this.output.x = rangeToObj(value)
        return this
    }

    public y(value : real_range) {
        eval this.output.y = rangeToObj(value)
        return this
    }

    public z(value : real_range) {
        eval this.output.z = rangeToObj(value)
        return this
    }

    public absolute(value : real_range) {
        eval this.output.absolute = rangeToObj(value)
        return this
    }

    public horizontal(value : real_range) {
        eval this.output.horizontal = rangeToObj(value)
        return this
    }

    public override serializeToJSON() {
        return output
    }
}

define private class Location : JSONSerializable {
    var output = {}

    public block(obj : Block) {
        eval this.output.block = obj
        return this
    }

    public fluid(obj : Fluid) {
        eval this.output.fluid = obj
        return this
    }

    public biome(biome : resource) {
        if(!MinecraftTypes.exists("biome", biome)) throw "Given type '" + biome + "' does not exist as a biome type"
        eval this.output.biome = biome
        return this
    }

    public light(value : int_range) {
        eval this.output.light = {
            "light": rangeToObj(value)
        }
        return this
    }

    public posX(value : real_range) {
        if(this.output.position == null) eval this.output.position = {}
        eval this.output.position.x = rangeToObj(value)
        return this
    }

    public posY(value : real_range) {
        if(this.output.position == null) eval this.output.position = {}
        eval this.output.position.y = rangeToObj(value)
        return this
    }

    public posZ(value : real_range) {
        if(this.output.position == null) eval this.output.position = {}
        eval this.output.position.z = rangeToObj(value)
        return this
    }

    public feature(feature : string) {
        eval feature = feature.toLowerCase()
        var valid = false
        for(def in MinecraftTypes.getDefinitionsForCategory("structure")) {
            if(def.key.toLowerCase() == feature) {
                eval valid = true
                break
            }
        }
        if(!valid) throw "Given type '" + feature + "' does not exist as a structure type"
        eval this.output.feature = feature
        return this
    }

    public dimension(dimension : resource) {
        if(!MinecraftTypes.exists("dimension", dimension)) throw "Given type '" + dimension + "' does not exist as a dimension type"
        eval this.output.dimension = dimension
        return this
    }

    public smokey(value : boolean) {
        if(Project.getTargetVersion()[1] < 16) throw "Location property 'smokey' is only available for versions 1.16 and up"
        eval this.output.smokey = value
        return this
    }

    public override serializeToJSON() {
        return output
    }
}

define private class Effect : JSONSerializable {
    var output = {}

    public new(type : resource) {
        if(!MinecraftTypes.exists("effect", type)) throw "Given type '" + type + "' does not exist as an effect type"
        eval output.id = type
    }

    public amplifier(value : int_range) {
        eval this.output.amplifier = rangeToObj(value)
        return this
    }

    public duration(value : int_range) {
        eval this.output.duration = rangeToObj(value)
        return this
    }

    public ambient(bool : boolean) {
        eval this.output.ambient = bool
        return this
    }

    public visible(bool : boolean) {
        eval this.output.visible = bool
        return this
    }

    public override serializeToJSON() {
        return output
    }
}

define private class Item : JSONSerializable {
    var output = {}

    public new() {}

    public new(base : custom_item) {
        eval this.type(base.baseType)
        eval this.nbt(base.getItemTag())
    }

    public new(base : item) {
        if(base.itemType.isTag) {
            eval this.tag(base.itemType)
        } else {
            eval this.type(base.itemType)
        }
        if(base.itemTag != null) {
            eval this.nbt(base.itemTag)
        }
    }

    public type(type : resource) {
        if(type.isTag) throw "Given location '" + type + "' is a tag, expected a type"
        if(!MinecraftTypes.exists("item", type)) throw "Given type '" + type + "' does not exist as an item type"
        eval this.output.item = type
        eval this.output.tag = null
        return this
    }

    public tag(type : resource) {
        if(!type.isTag) throw "Given location '" + type + "' is a type, expected a tag"
        if(!Tags.exists("item", type)) throw "Given tag '" + type + "' does not exist as an item tag"
        eval this.output.tag = ((string)type).substring(1)
        eval this.output.item = null
        return this
    }

    public durability(value : int_range) {
        eval this.output.durability = rangeToObj(value)
        return this
    }

    public count(value : int_range) {
        eval this.output.count = rangeToObj(value)
        return this
    }

    public potion(type : resource) {
        if(!MinecraftTypes.exists("potion", type)) throw "Given type '" + type + "' does not exist as a potion type"
        eval this.output.potion = type
        return this
    }

    public enchantments(obj : Enchantment) {
        return effects([obj])
    }
    public enchantments (enchantments : list) {
        if(this.output.enchantments == null) eval this.output.enchantments = []
        for(enchantment in enchantments) {
            eval this.output.enchantments.add((Enchantment)enchantment)
        }
        return this
    }

    public storedEnchantments(obj : Enchantment) {
        return effects([obj])
    }
    public storedEnchantments(enchantments : list) {
        if(this.output.stored_enchantments == null) eval this.output.stored_enchantments = []
        for(enchantment in enchantments) {
            eval this.output.stored_enchantments.add((Enchantment)enchantment)
        }
        return this
    }

    public nbt(tag : nbt) {
        if(this.output.nbt == null) eval this.output.nbt = nbt<{}>
        eval this.output.nbt = this.output.nbt.merge(tag)
        return this
    }

    public override serializeToJSON() {
        return output
    }
}

define private class Enchantment : JSONSerializable {
    var output = {}

    public new(base : resource) {
        eval this.id(base)
    }

    public id(type : resource) {
        if(!MinecraftTypes.exists("enchantment", type)) throw "Given type '" + type + "' does not exist as an enchantment type"
        eval this.output.enchantment = type
        return this
    }

    public levels(value : int_range) {
        eval this.output.levels = rangeToObj(value)
        return this
    }

    public override serializeToJSON() {
        return output
    }
}

define private class Block : JSONSerializable {
    var output = {}

    public new(base : block?) {
        if(base != null) {
            if(base.blockType.isTag) {
                eval this.tag(base.blockType)
            } else {
                eval this.type(base.blockType)
            }
            var state = base.blockState
            if(state != null) {
                for(entry in state) {
                    eval this.state(entry.key, entry.value)
                }
            }
            if(base.blockTag != null) {
                eval this.nbt(base.blockTag)
            }
        }
    }

    public type(type : resource) {
        if(type.isTag) throw "Given location '" + type + "' is a tag, expected a type"
        if(!MinecraftTypes.exists("block", type)) throw "Given type '" + type + "' does not exist as a block type"
        eval this.output.block = type
        eval this.output.tag = null
        return this
    }

    public tag(type : resource) {
        if(!type.isTag) throw "Given location '" + type + "' is a type, expected a tag"
        if(!Tags.exists("block", type)) throw "Given tag '" + type + "' does not exist as a block tag"
        eval this.output.tag = ((string)type).substring(1)
        eval this.output.block = null
        return this
    }

    public state(key : string, value : int_range) {
        if(this.output.state == null) eval this.output.state = {}
        eval this.output.state[key] = rangeToObj(value)
        return this
    }

    public state(key : string, value : boolean) {
        if(this.output.state == null) eval this.output.state = {}
        eval this.output.state[key] = value
        return this
    }

    public state(key : string, value : string) {
        if(this.output.state == null) eval this.output.state = {}
        eval this.output.state[key] = value
        return this
    }

    public nbt(tag : nbt) {
        if(this.output.nbt == null) eval this.output.nbt = nbt<{}>
        eval this.output.nbt = this.output.nbt.merge(tag)
        return this
    }

    public override serializeToJSON() {
        return output
    }
}

define private class Fluid : JSONSerializable {
    var output = {}

    public new(base : resource?) {
        if(base != null) {
            if(base.isTag) {
                eval this.tag(base)
            } else {
                eval this.type(base)
            }
        }
    }

    public type(type : resource) {
        if(type.isTag) throw "Given location '" + type + "' is a tag, expected a type"
        if(!MinecraftTypes.exists("fluid", type)) throw "Given type '" + type + "' does not exist as a fluid type"
        eval this.output.fluid = type
        eval this.output.tag = null
        return this
    }

    public tag(type : resource) {
        if(!type.isTag) throw "Given location '" + type + "' is a type, expected a tag"
        if(!Tags.exists("fluid", type)) throw "Given tag '" + type + "' does not exist as a fluid tag"
        eval this.output.tag = ((string)type).substring(1)
        eval this.output.fluid = null
        return this
    }

    public state(key : string, value : int_range) {
        if(this.output.state == null) eval this.output.state = {}
        eval this.output.state[key] = rangeToObj(value)
        return this
    }
    public state(key : string, value : boolean) {
        if(this.output.state == null) eval this.output.state = {}
        eval this.output.state[key] = value
        return this
    }
    public state(key : string, value : string) {
        if(this.output.state == null) eval this.output.state = {}
        eval this.output.state[key] = value
        return this
    }

    public override serializeToJSON() {
        return output
    }
}

define class Shared {
    public static final var Distance = Distance
    public static final var Location = Location
    public static final var Entity = Entity
    public static final var Effect = Effect
    public static final var Item = Item
    public static final var Enchantment = Enchantment
    public static final var Block = Block
    public static final var Fluid = Fluid

    # For backwards compatibility:
    public static Distance() {return new Distance()}
    public static Location() {return new Location()}
    public static Entity() {return new Entity()}
    public static Effect(type : resource) {return new Effect(type)}
    public static Item() {return new Item(base)}
    public static Item(base : item) {return new Item(base)}
    public static Item(base : custom_item) {return new Item(base)}
    public static Enchantment(base : resource) {return new Enchantment(base)}
    public static Block(base : block?) {return new Block(base)}
    public static Fluid(base : resource?) {return new Fluid(base)}
}
